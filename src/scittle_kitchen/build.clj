(ns scittle-kitchen.build
  "A way to build more plugins for scittle"
  (:require [babashka.deps :as deps]
            [babashka.fs :as fs]
            [babashka.process :refer [shell]]
            [cheshire.core :as json]
            [clojure.edn :as edn]
            [clojure.pprint :as pprint]
            [clojure.string :as str]))

(deps/add-deps '{:deps {camel-snake-kebab/camel-snake-kebab {:mvn/version "0.4.2"}}})
(require '[camel-snake-kebab.core :as csk])

;; ## Git versioning

(defn ensure-latest-scittle []
  ;; Full history for commit count
  (when (fs/exists? ".git/shallow")
    (shell {:out :string} "git" "fetch" "--unshallow"))

  ;; Latest tagged Scittle
  (shell {:dir "scittle" :out :string} "git" "fetch" "--tags")
  (let [latest-tag (-> (shell {:dir "scittle" :out :string} "git" "tag" "--sort=-creatordate")
                       :out
                       str/split-lines
                       first)]
    (if latest-tag
      (do (println (str "scittle-kitchen build Checking out scittle at tag: " latest-tag))
          (println (:out (shell {:dir "scittle" :out :string} "git" "checkout" latest-tag))))
      (println "No tag found"))))

;; ## Helpers

(defn slurp-edn [f & path]
  (cond-> (edn/read-string (slurp f))
    path (get-in path)))

(defn pretty-spit [f x]
  (spit f (with-out-str (binding [*print-namespace-maps* false]
                          (pprint/pprint x))))
  (println "scittle-kitchen build Created" (str f)))

;; ## Plugin expansion from template to file system

(defn plugin-edn [nm {:keys [namespaces depends-on]}]
  (let [module (str "scittle." nm)]
    [{:name (symbol "scittle" nm)
      :namespaces namespaces
      :js (str "./scittle." nm ".js")
      :shadow-config
      {:modules
       {(keyword module)
        {:init-fn (symbol module "init")
         :depends-on (into #{:scittle}
                           (for [k depends-on]
                             (keyword (str "scittle." (name k)))))
         :entries namespaces}}}}]))

(defn write-plugin [k plugin]
  (let [nm (name k)
        plugin-dir (fs/file "plugins" nm)
        src-dir (fs/file plugin-dir "src" "scittle")
        cljs-file (fs/file src-dir (str (csk/->snake_case nm) ".cljs"))
        edn-file (fs/file plugin-dir "src" "scittle_plugin.edn")
        deps-file (fs/file plugin-dir "deps.edn")
        ns-requires (str/join
                     "\n    "
                     (for [ns (:namespaces plugin)]
                       (str "[" ns "]")))
        config-map (str "{:namespaces\n   {"
                        (str/join
                         "\n    "
                         (for [ns (:namespaces plugin)]
                           (str "'" ns " (sci/copy-ns " ns " (sci/create-ns '" ns " nil))")))
                        "}}")]
    (fs/create-dirs src-dir)
    (spit (str cljs-file)
          (str "(ns scittle." nm "\n"
               "  {:no-doc true}\n"
               "  (:require [scittle.core :as scittle]\n"
               "            [sci.core :as sci]"
               (if (seq (:namespaces plugin))
                 (str "\n    " ns-requires)
                 "")
               "))\n\n"
               ";; Plugin: " nm "\n"
               ";; Generated by build.clj\n\n"
               "(defn init []\n"
               "  (scittle/register-plugin!\n"
               "   ::" nm "\n"
               "   " config-map "\n"
               "   ))\n"))
    (println "scittle-kitchen build Created" (str cljs-file))
    (pretty-spit edn-file (plugin-edn nm plugin))
    (pretty-spit deps-file {:deps (or (:deps plugin) {})})))

(defn expand-plugin-tempalates []
  (println "scittle-kitchen build Expanding plugin-templates.edn to plugins")
  (fs/create-dirs "plugins")
  (doseq [[k plugin] (slurp-edn "plugin-templates.edn")]
    (write-plugin k plugin)))

;; Discover Plugins from file system (more than in templates)

(defn find-plugins
  "Not all plugins are generated, so look for them in the plugin directories"
  [base]
  (->> (fs/list-dir base fs/directory?)
       (map fs/file-name)
       (remove #{"demo"})
       (map (fn [name]
              [(keyword name) (fs/file base name)]))
       (sort)))

(defn official-plugins []
  (find-plugins "scittle/plugins"))

(defn kitchen-plugins []
  (find-plugins "plugins"))

(defn find-plugin-roots
  "Note that kitchen plugins replace official plugins where both are defined"
  []
  (into {} (concat (official-plugins) (kitchen-plugins))))

(defn standard-plugins []
  (let [plugin-dir (fs/file "scittle" "src" "scittle")
        plugin-files (fs/list-dir plugin-dir (complement fs/directory?))]
    (->> (map (comp csk/->kebab-case fs/file-name fs/strip-ext) plugin-files)
         (remove #{"core"})
         (sort))))

;; ## Versioning

(defn git-sha
  ([] (git-sha nil))
  ([dir]
   (let [opts (cond-> {:out :string :continue true}
                dir (assoc :dir dir))
         result (shell opts "git" "rev-parse" "HEAD")]
     (if (= 0 (:exit result))
       (str/trim (:out result))
       (throw (ex-info (str "git rev-parse failed" (when dir (str " in " dir))) {:result result}))))))

(defn plugin-deps-map [plugin-path]
  (slurp-edn (fs/file plugin-path "deps.edn") :deps))

(defn git-tag
  ([] (git-tag nil))
  ([dir]
   (let [opts (cond-> {:out :string :continue true}
                dir (assoc :dir dir))
         result (shell opts "git" "describe" "--tags" "--abbrev=0")]
     (cond
       (= 0 (:exit result)) (str/trim (:out result))
       (= 128 (:exit result)) nil ; no tags found
       :else (throw (ex-info (str "git describe --tags failed" (when dir (str " in " dir))) {:result result}))))))

(defn kitchen-version []
  (let [scittle-version (git-tag "scittle")
        [major minor patch] (str/split scittle-version #"\.")
        commit-count (-> (shell {:out :string} "git" "rev-list" "--count" "HEAD") :out str/trim)]
    (str major "." minor "." patch "-" commit-count)))

(defn extract-dependencies-from-shadow-cljs []
  (let [shadow-config (slurp-edn (fs/file "scittle" "shadow-cljs.edn"))
        modules (get-in shadow-config [:builds :main :modules])]
    (into {}
          (for [[module-key module-config] modules
                :when (str/starts-with? (name module-key) "scittle.")
                :let [plugin-name (str/replace (name module-key) "scittle." "")
                      deps (:depends-on module-config)
                      plugin-deps (set (for [dep deps
                                            :when (and (keyword? dep)
                                                      (str/starts-with? (name dep) "scittle.")
                                                      (not= (name dep) "scittle"))]
                                        (str/replace (name dep) "scittle." "")))]]
            [plugin-name plugin-deps]))))

(defn extract-dependencies-from-plugin-edn
  [plugin-path]
  (try
    (let [plugin-edn-file (fs/file plugin-path "src" "scittle_plugin.edn")]
      (when (fs/exists? plugin-edn-file)
        (let [plugin-config (first (slurp-edn (str plugin-edn-file)))
              shadow-config (:shadow-config plugin-config)
              modules (:modules shadow-config)]
          (when modules
            (let [[_ module-config] (first modules)
                  deps (:depends-on module-config)
                  plugin-deps (set (for [dep deps
                                        :when (and (keyword? dep)
                                                  (str/starts-with? (name dep) "scittle.")
                                                  (not= (name dep) "scittle"))]
                                    (str/replace (name dep) "scittle." "")))]
              plugin-deps)))))
    (catch Exception e
      (println "Warning: Could not read plugin edn for" (str plugin-path) ":" (.getMessage e))
      #{})))

(defn build-complete-plugin-dependencies
  [plugins plugin-roots]
  (let [shadow-deps (extract-dependencies-from-shadow-cljs)
        plugin-edn-deps (into {}
                              (for [plugin plugins
                                    :let [plugin-name (name plugin)
                                          plugin-path (get plugin-roots plugin)
                                          deps (when plugin-path
                                                 (extract-dependencies-from-plugin-edn plugin-path))]
                                    :when deps]
                                [plugin-name deps]))]
    (merge shadow-deps plugin-edn-deps {"reagent" #{"react-dom"}
                                        "react-dom" #{"react"}})))

(defn manifest [plugins plugin-roots]
  {:version (kitchen-version)
   :scittle {:git-sha (git-sha "scittle")
             :git-tag (git-tag "scittle")}
   :scittle-kitchen {:git-sha (git-sha)}
   :plugins (into {} (for [plugin plugins]
                       [(name plugin) {:deps (plugin-deps-map (plugin-roots plugin))}]))
   :all-plugins (vec (sort (distinct (concat (standard-plugins) (map name plugins)))))
   :plugin-dependencies (build-complete-plugin-dependencies plugins plugin-roots)})

;; ## Landing page

(defn update-and-copy-index-html
  [target-dir manifest-data]
  (let [source-dir (fs/file "resources" "public")
        source-file (fs/file source-dir "index.html")
        target-file (fs/file target-dir "index.html")
        content (slurp source-file)
        {:keys [all-plugins plugin-dependencies]} manifest-data
        new-base-url "\"https://cdn.jsdelivr.net/npm/scittle-kitchen/dist/\""
        ;; Replace sections
        updated-content (-> content
                            (str/replace #"(?s)\(def base-url \"[^\"]+\"\)"
                                         (str "(def base-url " new-base-url ")"))
                            (str/replace #"(?s)\(def all-plugins\s+\[[^\]]+\]\)"
                                         (str "(def all-plugins\n  " (pr-str (vec (sort all-plugins))) ")"))
                            (str/replace #"\(def plugin-dependencies[\s\S]*?\}\)"
                                         (str "(def plugin-dependencies\n  " (pr-str plugin-dependencies) ")")))]
    (spit source-file updated-content)
    (spit target-file updated-content)
    (fs/copy (fs/file source-dir "favicon.ico")
             (fs/file target-dir "favicon.ico")
             {:replace-existing true})
    (println "scittle-kitchen build Created" (str target-file) "with updated plugin data")))

;; ## Build

(defn scittle-sci-version
  "Otherwise there will be a version conflict"
  []
  (slurp-edn "scittle/deps.edn" :deps 'org.babashka/sci))

(defn local [build path]
  {:local/root (str (fs/relativize build path))})

(defn make
  "Generate a deps.edn in <build-name> with plugins, scittle, and sci on the classpath."
  [plugins build-dir plugin-roots]
  (println "scittle-kitchen build Preparing" (str build-dir))
  (fs/create-dirs build-dir)
  (let [scittle-deps {'io.github.babashka/scittle (local build-dir "scittle")
                      'io.github.babashka/scittle.build (local build-dir (fs/file "scittle" "build"))
                      'org.babashka/sci (scittle-sci-version)}
        plugin-deps (map (fn [plugin]
                           [(symbol "scittle-kitchen.plugins" (str "scittle." (name plugin)))
                            (local build-dir (get plugin-roots plugin))])
                         plugins)
        deps (into scittle-deps plugin-deps)]
    (pretty-spit (fs/file build-dir "bb.edn")
                 {:deps deps
                  :tasks '{:requires ([scittle.build :as build])
                           release {:task (scittle.build/build {})}}})
    (pretty-spit (fs/file build-dir "deps.edn")
                 {:deps scittle-deps})
    ;; Avoid React version conflicts
    (spit (fs/file build-dir "package.json")
          (json/generate-string {:dependencies {:react "18.3.1"
                                                :react-dom "18.3.1"}}))
    (let [public-dir (fs/file build-dir "resources" "public")
          manifest-data (manifest plugins plugin-roots)]
      (fs/create-dirs public-dir)
      (pretty-spit (fs/file public-dir "manifest.edn") manifest-data)
      (update-and-copy-index-html public-dir manifest-data)
      (println "scittle-kitchen build Version" (:version manifest-data) "ready to compile"))))

;; Command line arguments

(defn -main [& args]
  (println "scittle-kitchen build Started")
  (ensure-latest-scittle)
  (expand-plugin-tempalates)
  (let [flags #{"--dry-run" "--dry" "--no-compile"}
        dry-run? (some flags args)
        args (remove flags args)
        std (set (standard-plugins))
        args (remove std args)
        plugin-roots (find-plugin-roots)
        plugins (if (seq args)
                  (mapv keyword args)
                  (keys plugin-roots))
        unknown (remove plugin-roots plugins)
        build (or (first args) "all")
        build-dir (fs/path "target" build)
        dest (fs/file "dist")]
    (if (seq unknown)
      (do (println "Unknown plugin:" (str/join ", " unknown))
          (println "Available plugins:" (str/join ", " (map name (keys plugin-roots))))
          (System/exit 1))
      (do (fs/delete-tree dest)
          ;; Scittle generates shadow-cljs.edn, remove it if left over from failed build
          (fs/delete-if-exists (fs/file build-dir "shadow-cljs.edn"))
          (make plugins build-dir plugin-roots)
          (if dry-run?
            (println "scittle-kitchen build Dry run complete - skipping compilation")
            (do
              (println "scittle-kitchen build Compiling ClojureScript")
              (shell {:dir build-dir} "bb" "release")
              (println "scittle-kitchen build Copied js to" build)
              (fs/copy-tree (fs/file build-dir "resources" "public" "js")
                            dest)))
          (println "scittle-kitchen build Done")))))
